<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>反应式编程 | ATAO2017,阿宅创造奇迹！</title><meta name="keywords" content="教程,C#"><meta name="author" content="ATAO2017"><meta name="copyright" content="ATAO2017"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="反应式编程的科普文章，翻译自https:&#x2F;&#x2F;gist.github.com&#x2F;staltz&#x2F;868e7e9bc2a7b8c1f754 什么是反应式编程微软的“反应式编程”指的是“Rx &#x3D; Observables + LINQ + Schedulers”，和其他的反应式编程的概念不太相同。 反应式编程用一句话总结就是： 反应式编程就是使用异步数据流进行编程 在某种程度上，这不是什么新鲜事。事">
<meta property="og:type" content="article">
<meta property="og:title" content="反应式编程">
<meta property="og:url" content="https://atao-blast.github.io/2022/09/30/CSharp/CSharp-tips-Rx/index.html">
<meta property="og:site_name" content="ATAO2017,阿宅创造奇迹！">
<meta property="og:description" content="反应式编程的科普文章，翻译自https:&#x2F;&#x2F;gist.github.com&#x2F;staltz&#x2F;868e7e9bc2a7b8c1f754 什么是反应式编程微软的“反应式编程”指的是“Rx &#x3D; Observables + LINQ + Schedulers”，和其他的反应式编程的概念不太相同。 反应式编程用一句话总结就是： 反应式编程就是使用异步数据流进行编程 在某种程度上，这不是什么新鲜事。事">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/CSharpTitlePic.png">
<meta property="article:published_time" content="2022-09-30T09:26:46.000Z">
<meta property="article:modified_time" content="2022-10-05T12:30:47.215Z">
<meta property="article:author" content="ATAO2017">
<meta property="article:tag" content="教程">
<meta property="article:tag" content="C#">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/CSharpTitlePic.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://atao-blast.github.io/2022/09/30/CSharp/CSharp-tips-Rx/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '反应式编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-05 20:30:47'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/头像2.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">391</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">96</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/CSharpTitlePic.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ATAO2017,阿宅创造奇迹！</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">反应式编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-30T09:26:46.000Z" title="发表于 2022-09-30 17:26:46">2022-09-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-05T12:30:47.215Z" title="更新于 2022-10-05 20:30:47">2022-10-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-%E7%9F%A5%E8%AF%86/">C#知识</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-%E7%9F%A5%E8%AF%86/C-Tips/">C#Tips</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="反应式编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>反应式编程的科普文章，翻译自<a target="_blank" rel="noopener" href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">https://gist.github.com/staltz/868e7e9bc2a7b8c1f754</a></p>
<h1 id="什么是反应式编程"><a href="#什么是反应式编程" class="headerlink" title="什么是反应式编程"></a>什么是反应式编程</h1><p>微软的“反应式编程”指的是“Rx &#x3D; Observables + LINQ + Schedulers”，和其他的反应式编程的概念不太相同。</p>
<p>反应式编程用一句话总结就是：</p>
<p><strong>反应式编程就是使用异步数据流进行编程</strong></p>
<p>在某种程度上，这不是什么新鲜事。事件总线或典型的单击事件实际上是一个异步事件流，您可以观察（Observe）并执行一些操作。反应式是相同的想法。您可以创建任何数据流，而不仅仅是单击和悬停事件。流是廉价且无处不在的，任何东西都可以是流：变量、用户输入、属性、缓存、数据结构等。例如，假设您的推特提要（Feed）是一个数据流，其方式与点击事件相同。你可以监听这个流并做出相应的反应。</p>
<p>除此之外，您还可以使用一个函数工具箱来组合、创建和过滤这些流。这就是“功能性”魔法发挥作用的地方。流可以用作另一个流的输入。甚至可以将多个流用作另一个流的输入。您可以合并两个流。您可以过滤一个流，以获得另一个只包含您感兴趣的事件的流。您可以将数据值从一个流映射到另一个新流。</p>
<p>既然流对Reactive非常重要，那么让我们从我们熟悉的“点击按钮”事件流开始，仔细看看它们。</p>
<p><img src="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E4%BA%8B%E4%BB%B6%E6%B5%81.png" alt="点击按钮事件流"></p>
<p><strong>流是按时间顺序排列的正在进行的事件的序列。</strong>它可以发出三种不同的信号：值（某种类型）、错误和“完成”信号。例如，当包含该按钮的当前窗口或视图关闭时，会发出“已完成”事件。</p>
<p>我们<strong>只异步捕获这些发出的事件</strong>，方法是定义一些函数，其中有的函数在发出值时执行，有的在发出错误时执行，有的在发出“完成”时执行。有时最后两个可以省略，您可以只专注于为值定义函数。“监听”流称为订阅（Subscribing）。我们定义的函数是观察者。流是被观察的对象（或“可观察的”）。这正是观察者设计模式。</p>
<p>绘制该图的另一种方法是使用ASCII，我们将在本教程的某些部分中使用它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--a---b-c---d---X---|-&gt;</span><br><span class="line"></span><br><span class="line">a, b, c, d are emitted values</span><br><span class="line">X is an error</span><br><span class="line">| is the &#x27;completed&#x27; signal</span><br><span class="line">---&gt; is the timeline</span><br></pre></td></tr></table></figure>

<p>由于这种感觉已经很熟悉了，我不想让你感到无聊，让我们做一些新的事情：我们将创建新的点击事件流，它是从原始点击事件流转换而来的。</p>
<p>首先，让我们创建一个计数器流，指示按钮被单击的次数。在常见的Reactive库中，每个流都有许多附加函数，例如映射(<code>Map</code>)、筛选(<code>Filter</code>)、扫描(<code>Scan</code>)等。当您调用其中一个函数时，例如<code>clickStream.map(f)</code>，会根据点击流返回一个新的流，它不会以任何方式修改原始单击流。这是一种被称为不变性(immutability)的特性，它与反应流（Reactive stream）相结合，就像煎饼与糖浆相结合一样。这允许我们链式编程<code>clickStream.map(f).scan(g)</code>等函数（这些看起来就和LINQ一样）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  clickStream: ---c----c--c----c------c--&gt;</span><br><span class="line">               vvvvv map(c becomes 1) vvvv</span><br><span class="line">               ---1----1--1----1------1--&gt;</span><br><span class="line">               vvvvvvvvv scan(+) vvvvvvvvv</span><br><span class="line">counterStream: ---1----2--3----4------5--&gt;</span><br></pre></td></tr></table></figure>

<p><code>map(f)</code>函数根据您提供的函数f替换（到新流中）每个发出的值。在我们的例子中，我们在每次点击时都映射到数字1。<code>scan(f)</code>函数聚合流上所有以前的值，生成值<code>x=g(accumulated，current)</code>，其中g只是本例中的add函数。然后，每当单击发生时，<code>counterStream</code>都会展示总的单击次数。</p>
<p>为了展示Reactive的真正威力，让我们假设您想要一系列“双击”事件。为了让它更有趣，假设我们希望新的流将三次单击（或者通常是多次单击（两次或更多））视为双击。深吸一口气，想象一下你将如何以传统的命令式和庄严的方式做到这一点。我敢打赌，这听起来相当恶心，涉及一些变量来保存状态，还涉及一些时间间隔。</p>
<p>然而，在Reactive中，这很简单。事实上，逻辑仅仅是4行代码。但现在让我们忽略代码。无论你是初学者还是专家，用图表思考是理解和构建流的最佳方式。</p>
<p><img src="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/%E7%82%B9%E5%87%BB%E6%B5%81%E7%9A%84%E8%BD%AC%E6%8D%A2.png" alt="图表展示点击流的转换"></p>
<p>灰色框是将一个流转换为另一个流的函数。首先，只要发生250毫秒的“事件静默”（简而言之，这就是<code>buffer(stream.throttle(250ms))</code>的作用），我们就会在列表中累积点击次数。此时不要担心理解细节，我们现在只是演示Reactive。结果是一个列表流，我们从中应用<code>map()</code>将每个列表映射到与该列表长度匹配的整数。最后，我们使用<code>filter(x&gt;=2)</code>函数忽略1个整数。就是这样：3次操作产生我们想要的流。然后，我们可以订阅（“监听”）它，从而根据我们的意愿做出相应的反应。</p>
<p>我希望你喜欢这种方法的美妙之处。这个例子只是冰山一角：您可以对不同类型的流应用相同的操作，例如，对API响应流；另一方面，还有许多其他可用功能。</p>
<h1 id="“为什么我应该考虑采用反应式编程”"><a href="#“为什么我应该考虑采用反应式编程”" class="headerlink" title="“为什么我应该考虑采用反应式编程”"></a>“为什么我应该考虑采用反应式编程”</h1><p>反应式编程提高了代码的抽象级别，因此您可以专注于定义业务逻辑的事件的相互依赖性，而不必不断地处理大量的实现细节。RP中的代码可能更简洁。</p>
<p>这种好处在现代Web应用程序和移动应用程序中更为明显，这些应用程序与大量与数据事件相关的UI事件高度交互。10年前，与web页面的交互基本上是向后端提交一个长表单，并在前端执行简单的呈现。应用程序已经发展为更实时的：修改单个表单字段可以自动触发后台保存，对某些内容的“赞”可以实时反映给其他连接的用户，等等。</p>
<p>如今的应用程序拥有丰富的各种实时事件，能够为用户提供高度互动的体验。我们需要工具来正确处理这一问题，而反应式编程就是一个答案。</p>
<h1 id="用反应式编程思考，并举例"><a href="#用反应式编程思考，并举例" class="headerlink" title="用反应式编程思考，并举例"></a>用反应式编程思考，并举例</h1><p>让我们深入了解真实情况。这是一个真实的例子，有一个关于如何用RP思考的分步指南。没有合成的例子，没有半点解释的概念。在本教程结束时，我们将生成真正的功能代码，同时了解我们为什么要做每件事。</p>
<p>我选择JavaScript和<a target="_blank" rel="noopener" href="https://github.com/reactivex/rxjs">RxJS</a>作为工具，原因是：JavaScript是目前最熟悉的语言，<a target="_blank" rel="noopener" href="https://reactivex.io/">Rx*库家族</a>广泛用于多种语言和平台（<a target="_blank" rel="noopener" href="https://github.com/dotnet/reactive">.Net</a>、<a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxJava">Java</a>、<a target="_blank" rel="noopener" href="https://reactivex.io/rxscala/">Scala</a>、<a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxClojure">Clojure</a>、<a target="_blank" rel="noopener" href="https://github.com/ReactiveX/rxjs">JavaScript</a>、<a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxRuby">Ruby</a>、<a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxPY">Python</a>、<a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxCpp">C++</a>、<a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift">Swift</a>、<a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxGroovy">Groovy</a>等）。因此，无论您的工具是什么，您都可以通过学习本教程来具体受益。</p>
<h1 id="实现一个“推荐关注”的窗口"><a href="#实现一个“推荐关注”的窗口" class="headerlink" title="实现一个“推荐关注”的窗口"></a>实现一个“推荐关注”的窗口</h1><p>在推特中有一个建议你关注某些账号的窗口</p>
<p><img src="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/%E6%8E%A8%E8%8D%90%E5%85%B3%E6%B3%A8.png" alt="推荐关注"></p>
<p>我们将重点模仿其核心特征，即：</p>
<ul>
<li>启动时，从API加载帐户数据并显示3个建议</li>
<li>单击“刷新”后，将3个其他帐户建议加载到3行中</li>
<li>单击帐户行上的“x”按钮，仅清除该当前帐户并显示另一个帐户</li>
<li>每行显示帐户的头像和指向其页面的链接</li>
</ul>
<p>我们可以忽略其他功能和按钮，因为它们是次要的。此外，Twitter最近向未经授权的公众关闭了其API，让我们为Github上的关注者构建UI，而不是Twitter。<a target="_blank" rel="noopener" href="https://docs.github.com/cn/rest/users#get-all-users">有一个用于获取用户的Github API</a>。</p>
<p>此操作的完整代码位于<a target="_blank" rel="noopener" href="http://jsfiddle.net/staltz/8jFJH/48/%E3%80%82">http://jsfiddle.net/staltz/8jFJH/48/。</a></p>
<h2 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h2><p>你如何使用Rx处理这个问题？首先，（几乎）一切都可以是一条流。这就是Rx咒语。让我们从最简单的特性开始：“启动时，从API加载3个帐户数据”。这里没有什么特别的，这只是关于（1）执行请求，（2）获得响应，（3）呈现响应。因此，让我们继续将我们的请求表示为流。起初，这会让人觉得有些过火，但我们需要从基础开始，对吗？</p>
<p>启动时，我们只需要执行一个请求，所以如果我们将其建模为数据流，那么它将是一个只有一个发出值的流。稍后，我们知道会有许多请求发生，但目前，这只是一个请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--a------|-&gt;</span><br><span class="line"></span><br><span class="line">Where a is the string &#x27;https://api.github.com/users&#x27;</span><br></pre></td></tr></table></figure>

<p>这是我们想要请求的URL流。无论何时发生请求事件，它都会告诉我们两件事：“When”和“What”。请求被执行时的“When”就是事件发出的时间，请求的内容“What”就是发出的值：一个包含URL的字符串。</p>
<p>在Rx*中，创建单个值的流非常简单。流的官方术语是“Observable”，因为它可以被观察到，但我发现它是一个愚蠢的名称，所以我称它为流。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestStream = <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">just</span>(<span class="string">&#x27;https://api.github.com/users&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>但现在，这只是一个字符串流，不执行其他操作，所以我们需要在发出该值时以某种方式发生一些事情。这是通过<a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypesubscribeobserver--onnext-onerror-oncompleted">订阅流</a>来完成的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">requestStream.<span class="title function_">subscribe</span>(<span class="keyword">function</span>(<span class="params">requestUrl</span>) &#123;</span><br><span class="line">  <span class="comment">// execute the request</span></span><br><span class="line">  jQuery.<span class="title function_">getJSON</span>(requestUrl, <span class="keyword">function</span>(<span class="params">responseData</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，我们正在使用jQuery Ajax回调（<a target="_blank" rel="noopener" href="https://devdocs.io/jquery/jquery.getjson">我们假设您已经知道了</a>）来处理请求操作的异步性。但请稍等，Rx用于处理异步数据流。该请求的响应不能是包含将来某个时间到达的数据的流吗？好吧，在概念层面上，它看起来确实很像，所以让我们试试看。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">requestStream.<span class="title function_">subscribe</span>(<span class="keyword">function</span>(<span class="params">requestUrl</span>) &#123;</span><br><span class="line">  <span class="comment">// execute the request</span></span><br><span class="line">  <span class="keyword">var</span> responseStream = <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">create</span>(<span class="keyword">function</span> (<span class="params">observer</span>) &#123;</span><br><span class="line">    jQuery.<span class="title function_">getJSON</span>(requestUrl)</span><br><span class="line">    .<span class="title function_">done</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123; observer.<span class="title function_">onNext</span>(response); &#125;)</span><br><span class="line">    .<span class="title function_">fail</span>(<span class="keyword">function</span>(<span class="params">jqXHR, status, error</span>) &#123; observer.<span class="title function_">onError</span>(error); &#125;)</span><br><span class="line">    .<span class="title function_">always</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; observer.<span class="title function_">onCompleted</span>(); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  responseStream.<span class="title function_">subscribe</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// do something with the response</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到jQuery.getJSON使用Ajax回调能够同时链接.done、.fail、.always，因为它返回的是XMLHTTPRequest的超集，这可能是JavaScript的特性之一，有待研究</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/create.md">Rx.Observable.create()</a>所做的是通过显式地通知每个观察者Observer（或者换句话说，“订阅者Subscriber”）数据事件（<code>onNext()</code>）或错误（<code>onError()</code>）来创建自己的自定义流。我们所做的只是包装了jQuery Ajax Promise。</p>
<p>请等一下，这是否意味着一个Promise就是一个Observable？（Promise可以简单理解为JavaScript的异步代码）</p>
<p>是的！</p>
<p>Observable是“Promise++”，在Rx里面你可以使用<code>var stream = Rx.Observable.fromPromise(promise)</code>来简单地将一个Promise转换为Observable，唯一的区别是Observables不符合<a target="_blank" rel="noopener" href="https://promisesaplus.com/">Promises&#x2F;A+</a>，但在概念上没有冲突。一个Promise就是一个只有单个值的Observable。Rx流允许许多返回值，比Promise更加强大。</p>
<p>这真的是非常好，目前我们展示了Observables至少和Promises一样强大。所以如果你是Promises的忠实粉丝，请接着看Observable能做到的更多的事。</p>
<p>现在让我们回到刚才举的例子，你可能很快就注意到，我们将一个<code>subscribe()</code>内嵌进了另一个<code>subscribe()</code>方法之中，看起来好像要进入一个“回调地狱”，并且，<code>responseStream</code>的创建依赖于<code>requestStream</code>。就像你之前听到的，在Rx中有更简单的机制来从一个流中转换的创建新的流，所以我们应该更改一下方式。</p>
<p>你目前应该知道的一个基础方法是<a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/select.md"><code>map(f)</code></a>，它获取流A的每个值，对其应用<code>f()</code>，并在流B上生成一个值。如果我们对请求和响应流这样做，我们可以将请求URL映射到响应Promises（伪装为流）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> responseMetastream = requestStream</span><br><span class="line">  .<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">requestUrl</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromPromise</span>(jQuery.<span class="title function_">getJSON</span>(requestUrl));</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>然后我们将创造出一种叫做“Metastream”的怪兽：包含一个（或多个）流的流。先不要惊慌，MetaStream是一个流，其中每个发出的值都是另一个流。你可以把它当成<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">指针</a>：MetaStream每一个发出的值都是指向另一个流的指针。在我们举的例子中，每个requestURL都映射到一个指向包含相应响应的Promise流的指针。</p>
<p><img src="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/responseMetastream.png" alt="Response metaStream"></p>
<p>用来响应的MetaStream看起来令人困惑，似乎对我们毫无帮助。我们只需要一个简单的响应流，其中每个发出的值都是一个JSON对象，而不是JSON对象的“Promise”。我们可以使用<a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/selectmany.md"><code>Flatmap</code></a>：它可以将MetaStream“扁平化”，通过在“主干”流上发射将在“分支”流上发出的所有内容。<code>Flatmap</code>不是一个“修复程序”，MetaStream也不是一个bug，它们确实是处理Rx中异步响应的工具。</p>
<p><img src="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/Flatmap.png" alt="flatMap"></p>
<p>很好，因为响应流是根据请求流定义的，如果我们稍后在请求流上发生更多事件，我们将在响应流上发生相应的响应事件，正如预期的那样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">requestStream:  --a-----b--c------------|-&gt;</span><br><span class="line">responseStream: -----A--------B-----C---|-&gt;</span><br><span class="line"></span><br><span class="line">(lowercase is a request, uppercase is its response)</span><br></pre></td></tr></table></figure>

<p>现在我们终于有了响应流，我们可以呈现我们接收到的数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">responseStream.<span class="title function_">subscribe</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">  <span class="comment">// render `response` to the DOM however you wish</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>将目前为止所有的代码加入进来，我们有：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestStream = <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">just</span>(<span class="string">&#x27;https://api.github.com/users&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> responseStream = requestStream</span><br><span class="line">  .<span class="title function_">flatMap</span>(<span class="keyword">function</span>(<span class="params">requestUrl</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromPromise</span>(jQuery.<span class="title function_">getJSON</span>(requestUrl));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">responseStream.<span class="title function_">subscribe</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">  <span class="comment">// render `response` to the DOM however you wish</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="刷新按钮"><a href="#刷新按钮" class="headerlink" title="刷新按钮"></a>刷新按钮</h2><p>我还没有提到响应中的JSON是一个包含100个用户的列表。API只允许我们指定页面偏移量，而不允许指定页面大小，因此我们只使用了3个数据对象，浪费了97个其他数据对象。我们现在可以忽略这个问题，因为稍后我们将看到如何缓存响应。</p>
<p>每次单击刷新按钮时，请求流都应该发出一个新的URL，以便我们可以获得新的响应。我们需要两件事：刷新按钮上的点击事件流（记住：任何东西都可以是流），我们需要更改依赖新点击流的请求流。令人欣慰的是，RxJS附带了一些工具，可以从事件侦听器生成Observable。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> refreshButton = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.refresh&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> refreshClickStream = <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(refreshButton, <span class="string">&#x27;click&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>由于刷新点击事件本身并不携带任何API URL，因此我们需要将每次点击映射到一个实际的URL。现在，我们将请求流更改为每次使用随机偏移参数映射到API端点的刷新点击流。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestStream = refreshClickStream</span><br><span class="line">  .<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> randomOffset = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://api.github.com/users?since=&#x27;</span> + randomOffset;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>因为我很笨，而且我没有自动化测试，所以我刚刚破坏了我们以前构建的一个特性。请求在启动时不再发生，只有在单击刷新时才会发生。啊。我需要两种行为：当点击刷新时发送请求或网页刚刚打开时也发送请求。</p>
<p>我们知道如何为每种情况创建单独的流：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestOnRefreshStream = refreshClickStream</span><br><span class="line">  .<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> randomOffset = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://api.github.com/users?since=&#x27;</span> + randomOffset;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> startupRequestStream = <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">just</span>(<span class="string">&#x27;https://api.github.com/users&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>但我们如何才能将这两者“合并”为一呢？嗯，我们有<a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/merge.md"><code>merge()</code></a>方法。用图表进行解释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stream A: ---a--------e-----o-----&gt;</span><br><span class="line">stream B: -----B---C-----D--------&gt;</span><br><span class="line">          vvvvvvvvv merge vvvvvvvvv</span><br><span class="line">          ---a-B---C--e--D--o-----&gt;</span><br></pre></td></tr></table></figure>

<p>所以我们现在就可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestOnRefreshStream = refreshClickStream</span><br><span class="line">  .<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> randomOffset = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://api.github.com/users?since=&#x27;</span> + randomOffset;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> startupRequestStream = <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">just</span>(<span class="string">&#x27;https://api.github.com/users&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> requestStream = <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">merge</span>(</span><br><span class="line">  requestOnRefreshStream, startupRequestStream</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>有一种替代的、更干净的写作方式，没有中间流。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestStream = refreshClickStream</span><br><span class="line">  .<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> randomOffset = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://api.github.com/users?since=&#x27;</span> + randomOffset;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">merge</span>(<span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">just</span>(<span class="string">&#x27;https://api.github.com/users&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>甚至能更短，更可读：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestStream = refreshClickStream</span><br><span class="line">  .<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> randomOffset = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://api.github.com/users?since=&#x27;</span> + randomOffset;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">startWith</span>(<span class="string">&#x27;https://api.github.com/users&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/startwith.md"><code>startWith()</code></a>方法所做的事就是你所想的那件事。无论输入流看起来如何，加上<code>startWith(x)</code>的输出流的开头都会有x。但我还不够<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a>，我在重复API端点字符串。解决此问题的一种方法是将<code>startWith()</code>移到<code>refreshClickStream</code>附近，实质上“模拟”启动时的刷新点击。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestStream = refreshClickStream.<span class="title function_">startWith</span>(<span class="string">&#x27;startup click&#x27;</span>)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> randomOffset = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://api.github.com/users?since=&#x27;</span> + randomOffset;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>如果回到我“破坏了自动化测试”的地方，您应该会看到，与最后一种方法的唯一区别是我添加了<code>startWith（）</code>。</p>
<h2 id="将三条推荐关注转为流"><a href="#将三条推荐关注转为流" class="headerlink" title="将三条推荐关注转为流"></a>将三条推荐关注转为流</h2><p>到目前为止，我们仅在渲染阶段，也就是响应流的<code>subscribe()</code>方法中涉及到了UI元素。现在，使用刷新按钮，我们遇到了一个问题：只要您单击“刷新”，当前的3个建议就不会被清除。只有在收到响应后才会有新的建议，但为了使UI看起来更好，我们需要在刷新时单击时清除当前的建议。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">refreshClickStream.<span class="title function_">subscribe</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// clear the 3 suggestion DOM elements </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>不，先别这样，伙计！这样做是不好的，因为我们现在有两个影响DOM元素的subscriber（另一个是<code>responseStream.subscribe()</code>），这听起来并不<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Separation_of_concerns">Separation of concerns</a>。还记得反应式编程的咒语吗？</p>
<p><img src="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/zmantra.jpg" alt="Everything is a stream"></p>
<p>因此，让我们将建议建模为流，其中每个发出的值都是包含建议数据的JSON对象。</p>
<p>我们将分别为3个建议中的每个建议执行此操作。suggestion#1的流程如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suggestion1Stream = responseStream</span><br><span class="line">  .<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">listUsers</span>) &#123;</span><br><span class="line">    <span class="comment">// get one random user from the list</span></span><br><span class="line">    <span class="keyword">return</span> listUsers[<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*listUsers.<span class="property">length</span>)];</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>其他的<code>suggition2Stream</code>和<code>suggition3Stream</code>可以简单地从<code>suggition1Stream</code>复制粘贴。这虽然并不<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a>，但它将使我们的示例在本教程中保持简单，另外，我认为在这种情况下，思考如何避免重复是一个很好的练习。</p>
<p>我们不是在responseStream的<code>subscribe()</code>中进行渲染，而是在这里进行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">suggestion1Stream.<span class="title function_">subscribe</span>(<span class="keyword">function</span>(<span class="params">suggestion</span>) &#123;</span><br><span class="line">  <span class="comment">// render the 1st suggestion to the DOM</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>回到“刷新时，清除建议”，我们可以简单地将刷新点击映射到空建议数据，并将其包含在<code>suggetion1Stream</code>中，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suggestion1Stream = responseStream</span><br><span class="line">  .<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">listUsers</span>) &#123;</span><br><span class="line">    <span class="comment">// get one random user from the list</span></span><br><span class="line">    <span class="keyword">return</span> listUsers[<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*listUsers.<span class="property">length</span>)];</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">merge</span>(</span><br><span class="line">    refreshClickStream.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<p>在呈现时，我们将null解释为“无数据”，从而隐藏其UI元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">suggestion1Stream.<span class="title function_">subscribe</span>(<span class="keyword">function</span>(<span class="params">suggestion</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (suggestion === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// hide the first suggestion DOM element</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// show the first suggestion DOM element</span></span><br><span class="line">    <span class="comment">// and render the data</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们的“大蓝图”就是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">refreshClickStream: ----------o--------o----&gt;</span><br><span class="line">     requestStream: -r--------r--------r----&gt;</span><br><span class="line">    responseStream: ----R---------R------R--&gt;   </span><br><span class="line"> suggestion1Stream: ----s-----N---s----N-s--&gt;</span><br><span class="line"> suggestion2Stream: ----q-----N---q----N-q--&gt;</span><br><span class="line"> suggestion3Stream: ----t-----N---t----N-t--&gt;</span><br></pre></td></tr></table></figure>

<p>其中的<code>N</code>指的是<code>null</code></p>
<p>另外，我们还可以在启动时提供“空”建议。这是通过将<code>startWith（null）</code>添加到建议流来实现的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suggestion1Stream = responseStream</span><br><span class="line">  .<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">listUsers</span>) &#123;</span><br><span class="line">    <span class="comment">// get one random user from the list</span></span><br><span class="line">    <span class="keyword">return</span> listUsers[<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*listUsers.<span class="property">length</span>)];</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">merge</span>(</span><br><span class="line">    refreshClickStream.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;)</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">startWith</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>最后都放到我们的蓝图里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">refreshClickStream: ----------o---------o----&gt;</span><br><span class="line">     requestStream: -r--------r---------r----&gt;</span><br><span class="line">    responseStream: ----R----------R------R--&gt;   </span><br><span class="line"> suggestion1Stream: -N--s-----N----s----N-s--&gt;</span><br><span class="line"> suggestion2Stream: -N--q-----N----q----N-q--&gt;</span><br><span class="line"> suggestion3Stream: -N--t-----N----t----N-t--&gt;</span><br></pre></td></tr></table></figure>



<h2 id="关闭建议并使用缓存的响应"><a href="#关闭建议并使用缓存的响应" class="headerlink" title="关闭建议并使用缓存的响应"></a>关闭建议并使用缓存的响应</h2><p>还有一个功能需要实现。每个建议都应该有自己的“x”按钮，用于关闭它，并在其位置加载另一个。乍一看，您可以说，当单击任何关闭按钮时，就可以发出新的请求：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> close1Button = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.close1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> close1ClickStream = <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(close1Button, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"><span class="comment">// and the same for close2Button and close3Button</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> requestStream = refreshClickStream.<span class="title function_">startWith</span>(<span class="string">&#x27;startup click&#x27;</span>)</span><br><span class="line">  .<span class="title function_">merge</span>(close1ClickStream) <span class="comment">// we added this</span></span><br><span class="line">  .<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> randomOffset = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://api.github.com/users?since=&#x27;</span> + randomOffset;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>这不起作用。它将关闭并重新加载所有建议，而不仅仅是我们单击的建议。有两种不同的方法可以解决这个问题，为了保持它的趣味性，我们将通过重用以前的响应来解决它。API的响应页面大小为100个用户，而我们只使用其中的3个，因此有大量新数据可用。没有必要要求更多。</p>
<p>同样，让我们把所有对象都放在“流”里。当发生“close1”点击事件时，我们希望使用<code>responseStream</code>上最近发出的响应，从响应列表中获取一个随机用户。像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    requestStream: --r---------------&gt;</span><br><span class="line">   responseStream: ------R-----------&gt;</span><br><span class="line">close1ClickStream: ------------c-----&gt;</span><br><span class="line">suggestion1Stream: ------s-----s-----&gt;</span><br></pre></td></tr></table></figure>

<p>在Rx*中有一个名为<a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/combinelatest.md">combinelatest</a>的组合函数，它似乎可以满足我们的需要。它将两个流A和B作为输入，每当其中一个流发出一个值时，<code>combineLatest</code>将从两个流中联接最近发出的两个值A和B，并输出一个值<code>c=f（x，y）</code>，其中f是您定义的函数。用图表来表示就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stream A: --a-----------e--------i--------&gt;</span><br><span class="line">stream B: -----b----c--------d-------q----&gt;</span><br><span class="line">          vvvvvvvv combineLatest(f) vvvvvvv</span><br><span class="line">          ----AB---AC--EC---ED--ID--IQ----&gt;</span><br><span class="line"></span><br><span class="line">where f is the uppercase function</span><br></pre></td></tr></table></figure>

<p>我们可以在<code>close1ClickStream</code>和<code>responseStream</code>上应用<code>combineLatest()</code>，这样每当单击close 1按钮时，我们都会得到发出的最新响应，并在<code>suggestion1Stream</code>上生成一个新值。另一方面，<code>combineLatest()</code>是对称的：每当在responseStream上发出新响应时，它将与最新的“close 1”单击相结合以生成新建议。这很有趣，因为它允许我们简化之前的<code>suggestion1Stream</code>代码，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suggestion1Stream = close1ClickStream</span><br><span class="line">  .<span class="title function_">combineLatest</span>(responseStream,             </span><br><span class="line">    <span class="keyword">function</span>(<span class="params">click, listUsers</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> listUsers[<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*listUsers.<span class="property">length</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">merge</span>(</span><br><span class="line">    refreshClickStream.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;)</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">startWith</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>拼图中仍缺少一块。<code>combineLatest()</code>使用两个源中最新的一个，但如果其中一个源尚未发出任何内容，则<code>combineLatest()</code>无法在输出流上生成数据事件。如果您查看上面的ASCII图，您将看到当第一个流发出值a时，输出没有任何内容。只有当第二个流发出了值b时，它才会产生输出值。</p>
<p>有不同的解决方法，我们将继续使用最简单的方法，即启动时模拟单击“关闭1”按钮的操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suggestion1Stream = close1ClickStream.<span class="title function_">startWith</span>(<span class="string">&#x27;startup click&#x27;</span>) <span class="comment">// we added this</span></span><br><span class="line">  .<span class="title function_">combineLatest</span>(responseStream,             </span><br><span class="line">    <span class="keyword">function</span>(<span class="params">click, listUsers</span>) &#123;l</span><br><span class="line">      <span class="keyword">return</span> listUsers[<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*listUsers.<span class="property">length</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">merge</span>(</span><br><span class="line">    refreshClickStream.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;)</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">startWith</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>终于完成了，全部代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> refreshButton = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.refresh&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> refreshClickStream = <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(refreshButton, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> closeButton1 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.close1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> close1ClickStream = <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromEvent</span>(closeButton1, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"><span class="comment">// and the same logic for close2 and close3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> requestStream = refreshClickStream.<span class="title function_">startWith</span>(<span class="string">&#x27;startup click&#x27;</span>)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> randomOffset = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://api.github.com/users?since=&#x27;</span> + randomOffset;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> responseStream = requestStream</span><br><span class="line">  .<span class="title function_">flatMap</span>(<span class="keyword">function</span> (<span class="params">requestUrl</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Rx</span>.<span class="property">Observable</span>.<span class="title function_">fromPromise</span>($.<span class="title function_">ajax</span>(&#123;<span class="attr">url</span>: requestUrl&#125;));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> suggestion1Stream = close1ClickStream.<span class="title function_">startWith</span>(<span class="string">&#x27;startup click&#x27;</span>)</span><br><span class="line">  .<span class="title function_">combineLatest</span>(responseStream,             </span><br><span class="line">    <span class="keyword">function</span>(<span class="params">click, listUsers</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> listUsers[<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*listUsers.<span class="property">length</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">merge</span>(</span><br><span class="line">    refreshClickStream.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;)</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">startWith</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// and the same logic for suggestion2Stream and suggestion3Stream</span></span><br><span class="line"></span><br><span class="line">suggestion1Stream.<span class="title function_">subscribe</span>(<span class="keyword">function</span>(<span class="params">suggestion</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (suggestion === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// hide the first suggestion DOM element</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// show the first suggestion DOM element</span></span><br><span class="line">    <span class="comment">// and render the data</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>You can see this working example at <a target="_blank" rel="noopener" href="http://jsfiddle.net/staltz/8jFJH/48/">http://jsfiddle.net/staltz/8jFJH/48/</a></strong></p>
<p>这段代码很小但很密集：它的特点是通过适当分离关注点来管理多个事件，甚至缓存响应。函数样式使代码看起来更具声明性，而不是命令性：我们并不是给出一系列要执行的指令，我们只是通过定义流之间的关系来告诉它是什么。例如，对于Rx，我们告诉计算机，<code>suggestion1Stream</code>是与来自最新响应的一个用户组合的“close 1”流，除了在刷新或程序启动时为空之外。</p>
<p>还请注意，令人印象深刻的是，这里没有<code>if</code>、<code>for</code>、<code>while</code>等控制流元素，以及您期望从JavaScript应用程序获得的典型的基于回调的控制流。如果需要，甚至可以通过使用<code>filter()</code>来除去上面<code>subscribe()</code>中的<code>if</code>和<code>else</code>（我将把实现细节留给您作为练习）。在Rx中，我们有流函数，如<code>map</code>、<code>filter</code>、<code>scan</code>、<code>merge</code>、<code>combineLatest</code>、<code>startWith</code>等，用于控制事件驱动程序的流。这个函数工具集以更少的代码为您提供了更强大的功能。</p>
<h1 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h1><p>如果您认为Rx*将是您首选的反应式编程库，请花点时间熟悉用于转换、组合和创建<a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md">Observables</a>的大量函数。如果您想了解流图中的那些函数，请查看<a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxJava/wiki/Creating-Observables">Creating Observables · ReactiveX&#x2F;RxJava</a>。每当您在尝试做某事时遇到困难，请绘制这些图表，仔细思考，查看长长的函数列表，并进行更多思考。根据我的经验，此工作流是有效的。</p>
<p>一旦你开始掌握Rx*编程的窍门，就绝对需要理解<a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/creating.md#cold-vs-hot-observables">cold-vs-hot-observables</a>的概念。如果你忽视这一点，它会回来残忍地咬你。你已经被警告过了。通过学习真正的函数式编程，并熟悉影响Rx*的副作用等问题，进一步提高您的技能。</p>
<p>但反应式编程不仅仅是Rx*。<a target="_blank" rel="noopener" href="http://baconjs.github.io/">Bacon.js </a>使用起来很直观，没有您在Rx*中有时遇到的怪癖。<a target="_blank" rel="noopener" href="https://elm-lang.org/">Elm语言</a>属于自己的类别：它是一种函数式反应式编程语言，可编译为JavaScript+HTML+CSS，并具有穿越时间的调试器。非常棒。</p>
<p>Rx非常适合event巨多的前端和应用程序。但这不仅仅是客户端的事情，它在后端和靠近数据库的地方也能很好地工作。事实上，<a target="_blank" rel="noopener" href="https://netflixtechblog.com/reactive-programming-in-the-netflix-api-with-rxjava-7811c3a1496a">RxJava是Netflix API中实现服务器端并发的关键组件</a>。Rx不是一个局限于特定类型应用程序或语言的框架。在编写任何事件驱动软件时，它确实是一个可以使用的范例。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://atao-blast.github.io">ATAO2017</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://atao-blast.github.io/2022/09/30/CSharp/CSharp-tips-Rx/">https://atao-blast.github.io/2022/09/30/CSharp/CSharp-tips-Rx/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://atao-blast.github.io" target="_blank">ATAO2017,阿宅创造奇迹！</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%99%E7%A8%8B/">教程</a><a class="post-meta__tags" href="/tags/C/">C#</a></div><div class="post_share"><div class="social-share" data-image="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/CSharpTitlePic.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/06/ATAOFrameWork/FrameWork-Season2Note26/"><img class="prev-cover" src="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/Snipaste_2022-06-27_15-08-47.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">捡枪实现</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/29/ATAOFrameWork/FrameWork-Season2Note25/"><img class="next-cover" src="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/Snipaste_2022-06-27_15-08-47.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">填弹实现</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/03/13/CSharp/CSharp-advance1/" title="C#文件操作"><img class="cover" src="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/CSharpTitlePic.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-13</div><div class="title">C#文件操作</div></div></a></div><div><a href="/2022/04/06/CSharp/CSharp-advance3/" title="网络Socket"><img class="cover" src="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/CSharpTitlePic.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-06</div><div class="title">网络Socket</div></div></a></div><div><a href="/2022/06/06/CSharp/CSharp-tips2/" title="List.Sort自定义排序附Unity应用"><img class="cover" src="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/CSharpTitlePic.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-06</div><div class="title">List.Sort自定义排序附Unity应用</div></div></a></div><div><a href="/2022/03/29/CSharp/CSharp-tips1/" title="async、await总结"><img class="cover" src="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/CSharpTitlePic.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-29</div><div class="title">async、await总结</div></div></a></div><div><a href="/2022/03/27/CSharp/CSharp-advance2/" title="Task、asyn和await"><img class="cover" src="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/CSharpTitlePic.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-27</div><div class="title">Task、asyn和await</div></div></a></div><div><a href="/2022/06/17/CSharp/Csharp-tips4/" title="C# 枚举的位运算"><img class="cover" src="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/CSharpTitlePic.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-17</div><div class="title">C# 枚举的位运算</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/头像2.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ATAO2017</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">391</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">96</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/170871791?spm_id_from=333.1007.0.0"><i class="fas fa-heart"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ATAO-Blast" target="_blank" title="Github主页"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:zerwart@outlook.com" target="_blank" title="Email邮箱"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到ATAO2017的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">什么是反应式编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%9C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E9%87%87%E7%94%A8%E5%8F%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E2%80%9D"><span class="toc-number">2.</span> <span class="toc-text">“为什么我应该考虑采用反应式编程”</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8%E5%8F%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E8%80%83%EF%BC%8C%E5%B9%B6%E4%B8%BE%E4%BE%8B"><span class="toc-number">3.</span> <span class="toc-text">用反应式编程思考，并举例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E2%80%9C%E6%8E%A8%E8%8D%90%E5%85%B3%E6%B3%A8%E2%80%9D%E7%9A%84%E7%AA%97%E5%8F%A3"><span class="toc-number">4.</span> <span class="toc-text">实现一个“推荐关注”的窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94"><span class="toc-number">4.1.</span> <span class="toc-text">请求和响应</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E6%8C%89%E9%92%AE"><span class="toc-number">4.2.</span> <span class="toc-text">刷新按钮</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E4%B8%89%E6%9D%A1%E6%8E%A8%E8%8D%90%E5%85%B3%E6%B3%A8%E8%BD%AC%E4%B8%BA%E6%B5%81"><span class="toc-number">4.3.</span> <span class="toc-text">将三条推荐关注转为流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E5%BB%BA%E8%AE%AE%E5%B9%B6%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E7%9A%84%E5%93%8D%E5%BA%94"><span class="toc-number">4.4.</span> <span class="toc-text">关闭建议并使用缓存的响应</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5"><span class="toc-number">6.</span> <span class="toc-text">接下来</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/02/05/NationalFighterJets/Chapter4Part7/" title="新手引导UI系统"><img src="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/NationalFighterJet1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="新手引导UI系统"/></a><div class="content"><a class="title" href="/2024/02/05/NationalFighterJets/Chapter4Part7/" title="新手引导UI系统">新手引导UI系统</a><time datetime="2024-02-05T02:16:10.000Z" title="发表于 2024-02-05 10:16:10">2024-02-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/04/NationalFighterJets/Chapter4Part6/" title="新手引导设计规范"><img src="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/NationalFighterJet1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="新手引导设计规范"/></a><div class="content"><a class="title" href="/2024/02/04/NationalFighterJets/Chapter4Part6/" title="新手引导设计规范">新手引导设计规范</a><time datetime="2024-02-04T08:49:33.000Z" title="发表于 2024-02-04 16:49:33">2024-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/01/NationalFighterJets/Chapter4Part5/" title="UI挖孔高亮工具"><img src="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/NationalFighterJet1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UI挖孔高亮工具"/></a><div class="content"><a class="title" href="/2024/02/01/NationalFighterJets/Chapter4Part5/" title="UI挖孔高亮工具">UI挖孔高亮工具</a><time datetime="2024-02-01T14:54:14.000Z" title="发表于 2024-02-01 22:54:14">2024-02-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/30/NationalFighterJets/Chapter4Part4/" title="ID赋值工具"><img src="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/NationalFighterJet1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ID赋值工具"/></a><div class="content"><a class="title" href="/2024/01/30/NationalFighterJets/Chapter4Part4/" title="ID赋值工具">ID赋值工具</a><time datetime="2024-01-30T08:59:30.000Z" title="发表于 2024-01-30 16:59:30">2024-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/29/NationalFighterJets/Chapter4Part3/" title="和UI模块的交互"><img src="https://atao-screenshots.oss-cn-beijing.aliyuncs.com/ScreenShots/NationalFighterJet1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="和UI模块的交互"/></a><div class="content"><a class="title" href="/2024/01/29/NationalFighterJets/Chapter4Part3/" title="和UI模块的交互">和UI模块的交互</a><time datetime="2024-01-29T08:31:48.000Z" title="发表于 2024-01-29 16:31:48">2024-01-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By ATAO2017</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">ATAO2017，阿宅创造奇迹</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>